
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>fsyncd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Omarmeks89/fsyncd/config.go (0.0%)</option>
				
				<option value="file1">github.com/Omarmeks89/fsyncd/fsync.go (54.3%)</option>
				
				<option value="file2">github.com/Omarmeks89/fsyncd/log.go (56.2%)</option>
				
				<option value="file3">github.com/Omarmeks89/fsyncd/main.go (0.0%)</option>
				
				<option value="file4">github.com/Omarmeks89/fsyncd/server.go (17.0%)</option>
				
				<option value="file5">github.com/Omarmeks89/fsyncd/synchronizer.go (0.0%)</option>
				
				<option value="file6">github.com/Omarmeks89/fsyncd/time_generator.go (45.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// contains application server configuration
package main

import (
        "github.com/go-playground/validator/v10"
        "gopkg.in/yaml.v3"
        "io"
        "os"
        "sync"
        "time"
)

// DefaultConfigName for detect config file
const DefaultConfigName = "fsync.yml"
const DriverConfigFilename = "driver_config.yml"

// ServerConfig contains all required server parameters
type ServerConfig struct {
        // server section
        Host string `yaml:"host" validate:"required,ipv4"`
        Port string `yaml:"port" validate:"required,numeric"`

        // swagger section
        SwaggerEnabled bool   `yaml:"swagger_enabled" validate:"required"`
        SwaggerPort    string `yaml:"swagger_port" validate:"numeric"`

        ConfigDriver string `yaml:"config_driver" validate:"required,oneof=vault default"`

        // connection settings
        ConnReadTimeout         time.Duration `yaml:"conn_read_timeout" validate:"required"`
        ConnWriteTimeout        time.Duration `yaml:"conn_write_timeout" validate:"required"`
        GracefulShutdownTimeout time.Duration `yaml:"graceful_shutdown_timeout" validate:"required"`

        // CORS
        AllowedHosts   []string `yaml:"allowed_hosts" validate:"required"`
        AllowedMethods []string `yaml:"allowed_methods" validate:"required"`
        AllowedHeaders []string `yaml:"allowed_headers" validate:"required"`

        // logger section
        TimeFormat string `yaml:"time_format" validate:"required"`
        LogLevel   string `yaml:"log_level" validate:"required"`

        lock *sync.RWMutex
}

// Load parameters from config file and setup config
func (sc *ServerConfig) Load() (err error) <span class="cov0" title="0">{
        var file *os.File
        var buf []byte

        if file, err = os.Open(DefaultConfigName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if buf, err = io.ReadAll(file); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = yaml.Unmarshal(buf, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = sc.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

// Validate config fields and return error if validation failed
func (sc *ServerConfig) Validate() (err error) <span class="cov0" title="0">{
        v := validator.New(validator.WithRequiredStructEnabled())
        if err = v.Struct(sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

type SyncConfig struct {
        SrcPath        string `yaml:"src_path" json:"src_path" validate:"required,dirpath"`
        DstPath        string `yaml:"dst_path" json:"dst_path" validate:"required,dirpath,nefield=SrcPath"`
        MaxDiffPercent int    `yaml:"max_diff_percent" json:"max_diff_percent" validate:"required,gt=0,lte=100"`
        SyncTime       string `yaml:"sync_time" json:"sync_time" validate:"required"`
}

type DefaultConfigDriver struct{}

func (d DefaultConfigDriver) LoadSyncConfig() (
        c SyncConfig,
        err error,
) <span class="cov0" title="0">{
        var file *os.File
        var buf []byte

        if file, err = os.Open(DriverConfigFilename); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">if buf, err = io.ReadAll(file); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">if err = yaml.Unmarshal(buf, &amp;c); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">if err = d.Validate(&amp;c); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">return c, err</span>
}

func (d DefaultConfigDriver) Validate(c *SyncConfig) (err error) <span class="cov0" title="0">{
        vld := validator.New(validator.WithRequiredStructEnabled())
        if err = vld.Struct(c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (d DefaultConfigDriver) UpdateSyncConfig(nc SyncConfig) (err error) <span class="cov0" title="0">{
        var buf []byte
        var file *os.File
        var stat os.FileInfo

        if err = d.Validate(&amp;nc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if stat, err = os.Stat(DriverConfigFilename); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // open file with same file mode
        <span class="cov0" title="0">if file, err = os.OpenFile(
                DriverConfigFilename,
                os.O_RDWR|os.O_TRUNC,
                stat.Mode(),
        ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        if buf, err = yaml.Marshal(&amp;nc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err = file.Write(buf); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Module contain functions and types to sync data
// between fs

package main

import (
        "fmt"
        "io/fs"
        "os"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// DefaultBufferSize for intermediate buffer
const DefaultBufferSize = 4096

const DefaultDirAllocSize = 16

// DefaultSyncObjectsSize set allocation size for nested SyncCommand collections
const DefaultSyncObjectsSize = 16

// DefaultRootDirMask default name for masked directories
const DefaultRootDirMask = "%-m-%"

var TooLargeDifferenceErr = fmt.Errorf("too many files not exists")

type SyncPair struct {
        // Src full path to source file
        Src string

        // Dst full path to destination file
        Dst string

        // Perm file permissions
        Perm fs.FileMode
}

// NewDirectory is used for create new directory in dst
type NewDirectory struct {
        // full path for create directory
        DirPath string

        // directory permissions
        DirMode fs.FileMode
}

// SyncCommand create all data for successful sync execution
type SyncCommand struct {
        // max possible difference between directories
        SrcDiffPercent int

        // FilesToDelete contain full paths for files have to be deleted
        // collect in map to run parallel
        FilesToDelete map[string][]string

        // full paths for create directories
        DirsToCreate []NewDirectory

        // full path to dirs to delete
        DirsToDelete []string

        // SyncPairs (src, dst) contain full source and destination paths
        // for synchronized objects
        SyncPairs []SyncPair

        log *logrus.Logger
}

func MakeSyncCommand(SrcDiffPercent int) SyncCommand <span class="cov8" title="1">{
        toDel := make(map[string][]string, DefaultSyncObjectsSize)
        pairs := make([]SyncPair, 0, DefaultSyncObjectsSize)
        paths := make([]NewDirectory, 0, DefaultSyncObjectsSize)
        dirsToDel := make([]string, 0, DefaultSyncObjectsSize)

        return SyncCommand{
                FilesToDelete:  toDel,
                SyncPairs:      pairs,
                SrcDiffPercent: SrcDiffPercent,
                DirsToCreate:   paths,
                DirsToDelete:   dirsToDel,
        }
}</span>

// Prepare meta information for synchronization
// Return error if sync is impossible
func (s *SyncCommand) Prepare(src SyncMeta, dst SyncMeta) (err error) <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nil receiver not allowed")
        }</span>
        <span class="cov8" title="1">return s.prepare(src, dst)</span>
}

// CompareRoot src and dest directory
// return true if entries count are equal or src - dest &lt; x% different
func (s *SyncCommand) CompareRoot(src Sized, dest Sized) (
        status bool,
        err error,
) <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return status, fmt.Errorf("nil receiver not allowed")
        }</span>

        <span class="cov8" title="1">if src == nil || dest == nil </span><span class="cov0" title="0">{
                return status, fmt.Errorf("nil container not allowed")
        }</span>

        <span class="cov8" title="1">srcSize, dstSize := src.FilesCount(), dest.FilesCount()
        diff := srcSize - dstSize
        if diff &lt; 0 </span><span class="cov8" title="1">{
                diff = -diff
        }</span>
        <span class="cov8" title="1">maxObj := max(srcSize, dstSize)
        percent := int(float64(diff) / float64(maxObj) * 100)

        // check that diff is less than max possible
        return percent &lt; s.SrcDiffPercent, err</span>
}

// prepare nested do all work
func (s *SyncCommand) prepare(src SyncMeta, dst SyncMeta) (err error) <span class="cov8" title="1">{
        var ok bool
        var dstDirectory Directory

        // check size diff (less than x%) between src and dest directories
        if ok, err = s.CompareRoot(&amp;src, &amp;dst); !ok </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // domain directories are different - break
                // return signal error
                <span class="cov8" title="1">return TooLargeDifferenceErr</span>
        }

        <span class="cov8" title="1">for dirName, directory := range src.Dirs </span><span class="cov8" title="1">{

                // overwrite nested path as a full path to directory
                srcFullPath := s.replaceRootMask(
                        directory.NestedPath,
                        src.MountPoint,
                )

                dstFullPath := s.replaceRootMask(
                        directory.NestedPath,
                        dst.MountPoint,
                )

                // directory not found in dst directory - we have
                // to make task to create this directory in dst
                if dstDirectory, ok = dst.Dirs[dirName]; !ok </span><span class="cov0" title="0">{

                        if dirName == DefaultRootDirMask </span><span class="cov0" title="0">{
                                // dst root dir not created, we can`t continue
                                return fmt.Errorf("no root destination directory")
                        }</span>

                        <span class="cov0" title="0">newDir := NewDirectory{
                                DirPath: dstFullPath,
                                DirMode: directory.Perm,
                        }
                        s.DirsToCreate = append(s.DirsToCreate, newDir)</span>
                }

                <span class="cov8" title="1">directory.NestedPath = srcFullPath
                dstDirectory.NestedPath = dstFullPath

                // set name (if not set - directory not exists) to
                // group files for delete (if exists)
                if dstDirectory.Name == "" </span><span class="cov0" title="0">{
                        dstDirectory.Name = directory.Name
                }</span>

                // create task for sync files
                <span class="cov8" title="1">if err = s.configureSyncActions(directory, dstDirectory); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // add directories (that not exists in src) to delete
        <span class="cov8" title="1">for dirname, dstDir := range dst.Dirs </span><span class="cov8" title="1">{

                if _, ok = src.Dirs[dirname]; !ok </span><span class="cov0" title="0">{
                        // directory not exists in source - delete
                        dstFullPath := s.replaceRootMask(
                                dstDir.NestedPath,
                                dst.MountPoint,
                        )

                        s.DirsToDelete = append(s.DirsToDelete, dstFullPath)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// replaceRootMask will replace 'root' mask with exact root path. If
// no 'root' mask found in string - return nestedPath
func (s *SyncCommand) replaceRootMask(
        nestedPath string,
        rootPath string,
) string <span class="cov8" title="1">{
        return strings.Replace(nestedPath, DefaultRootDirMask, rootPath, 1)
}</span>

// configureSyncActions generate tasks to sync and tasks to delete
func (s *SyncCommand) configureSyncActions(
        src Directory,
        dst Directory,
) (err error) <span class="cov8" title="1">{
        var srcPath, dstPath, fPath, delKey string

        for k, v := range src.Files </span><span class="cov8" title="1">{
                srcPath, err = MergePath(s.prepareRoot(src.NestedPath), "/", k)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">dstPath, err = MergePath(s.prepareRoot(dst.NestedPath), "/", k)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">syncPair := SyncPair{
                        Src: srcPath,
                        Dst: dstPath,
                        // dest inherit file permissions from source
                        Perm: v.Perm,
                }

                // if file by key not exists we will handle empty time value
                if v.ModTime.Before(dst.Files[k].ModTime) </span><span class="cov8" title="1">{
                        // rotate roots if file in destination directory
                        // have newer version (latest modification time) than
                        // file in master directory
                        syncPair.Src, syncPair.Dst = syncPair.Dst, syncPair.Src

                        // update permissions for source file
                        syncPair.Perm = dst.Files[k].Perm
                }</span>

                <span class="cov8" title="1">if _, ok := dst.Files[k]; ok </span><span class="cov8" title="1">{
                        delete(dst.Files, k)
                }</span>

                <span class="cov8" title="1">s.SyncPairs = append(s.SyncPairs, syncPair)</span>
        }

        <span class="cov8" title="1">for k, _ := range dst.Files </span><span class="cov8" title="1">{

                fPath, err = MergePath(s.prepareRoot(dst.NestedPath), "/", k)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // make del key
                <span class="cov8" title="1">if delKey, err = MergePath(dst.Name, k); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // add full path to destination
                <span class="cov8" title="1">s.FilesToDelete[delKey] = append(s.FilesToDelete[delKey], fPath)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *SyncCommand) prepareRoot(root string) string <span class="cov8" title="1">{
        if root == "" </span><span class="cov8" title="1">{
                return "."
        }</span>
        <span class="cov8" title="1">return root</span>
}

func MergePath(str ...string) (res string, err error) <span class="cov8" title="1">{
        var buf strings.Builder

        for _, sp := range str </span><span class="cov8" title="1">{
                if _, err = buf.WriteString(sp); err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>
        }
        <span class="cov8" title="1">return buf.String(), err</span>
}

// Sized return own size as elements count
type Sized interface {
        FilesCount() int
}

// Directory represent files collection where key is a full path
// and value is modification time
type Directory struct {
        // Files collection of file names (as key) and meta information (as value)
        Files map[string]FileMeta

        // NestedPath path to directory (inside root directory without filename)
        NestedPath string

        // masked directory name in case we
        // need to have same dir names for speedup search
        Mask string

        // current directory real name
        Name string

        // permissions
        Perm fs.FileMode
}

func (dir *Directory) FilesCount() int <span class="cov8" title="1">{
        return len(dir.Files)
}</span>

// FileMeta all required meta data at the moment
type FileMeta struct {
        // ModTime contain last modification time
        ModTime time.Time

        // Perm file permissions
        Perm fs.FileMode
}

// SyncMeta collect meta information about synchronized
// objects
type SyncMeta struct {
        // slice of directories for sync
        Dirs map[string]Directory

        // MountPoint is equal to root path
        MountPoint string
}

// MakeSyncMeta factory function return new SyncMeta object
func MakeSyncMeta() SyncMeta <span class="cov0" title="0">{
        dirs := make(map[string]Directory, DefaultDirAllocSize)
        return SyncMeta{
                Dirs: dirs,
        }
}</span>

// MakeMeta iterate through internal root directory objects
// and collect meta information about files
func (sm *SyncMeta) MakeMeta(root string) (err error) <span class="cov0" title="0">{
        // handle nil pointer
        var info os.FileInfo

        if sm == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("nil SyncMeta pointer")
        }</span>

        <span class="cov0" title="0">if info, err = os.Stat(root); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        // set mount point
        <span class="cov0" title="0">sm.MountPoint = root

        // build root directory with masked name - later
        // we can find root dirs at sync start by this name
        files := make(map[string]FileMeta, DefaultSyncObjectsSize)
        dir := Directory{
                Mask:       DefaultRootDirMask,
                Name:       info.Name(), // set real name to Name
                NestedPath: root,
                Files:      files,
                Perm:       info.Mode(),
        }

        sm.Dirs[dir.Mask] = dir
        return sm.makeMeta(root, dir.Mask, dir.Mask)</span>
}

// FilesCount return count of files
func (sm *SyncMeta) FilesCount() (size int) <span class="cov8" title="1">{
        for _, directory := range sm.Dirs </span><span class="cov8" title="1">{
                size += directory.FilesCount()
        }</span>
        <span class="cov8" title="1">return size</span>
}

// makeMeta do all job
func (sm *SyncMeta) makeMeta(
        root string,
        nestedPath string,
        dirName string,
) (err error) <span class="cov0" title="0">{
        var files []os.DirEntry
        var info, dInfo os.FileInfo
        var rootPath, dPath string

        if files, err = os.ReadDir(root); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">currDir := sm.Dirs[dirName]

        for _, file := range files </span><span class="cov0" title="0">{

                if ok := file.IsDir(); !ok </span><span class="cov0" title="0">{

                        // is a file, let`s add file meta into Directory
                        if info, err = file.Info(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // save by filename (not by full path)
                        <span class="cov0" title="0">currDir.Files[info.Name()] = FileMeta{
                                ModTime: info.ModTime(),
                                Perm:    info.Mode(),
                        }

                        continue</span>
                }

                // build required path only if we are directory
                <span class="cov0" title="0">if rootPath, err = MergePath(root, "/", file.Name()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if dPath, err = MergePath(nestedPath, "/", file.Name()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // create new nested directory
                <span class="cov0" title="0">fCollection := make(map[string]FileMeta, DefaultSyncObjectsSize)
                if dInfo, err = file.Info(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dir := Directory{
                        Mask:       "",
                        Name:       file.Name(), // set real name to Name
                        NestedPath: dPath,
                        Files:      fCollection,
                        Perm:       dInfo.Mode(),
                }

                // save nested directories by real name because
                // they have to be same between synced directories
                // (but root paths are different)
                sm.Dirs[dir.Name] = dir

                // is another directory - dive
                if err = sm.makeMeta(rootPath, dPath, dir.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// contain logger presets for daemon

package main

import (
        "fmt"
        "github.com/sirupsen/logrus"
        "strings"
)

const (
        InfoLevel  = "info"
        DebugLevel = "debug"
        WarnLevel  = "warn"
        ErrorLevel = "error"
        PanicLevel = "panic"
        FatalLevel = "fatal"
)

var UnexpectedLevel = fmt.Errorf("unexpected level")

// SetupLogger return new logger
func SetupLogger(level string, tmFmt string) (log *logrus.Logger, err error) <span class="cov0" title="0">{
        var lv logrus.Level

        log = logrus.New()

        if lv, err = convertLogLevel(level); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.SetLevel(lv)
        log.SetFormatter(&amp;logrus.JSONFormatter{TimestampFormat: tmFmt})

        return log, err</span>
}

// convertLogLevel convert log level (as a string) into logrus.Level
func convertLogLevel(level string) (l logrus.Level, err error) <span class="cov8" title="1">{
        level = strings.ToLower(level)

        switch level </span>{
        case InfoLevel:<span class="cov8" title="1">
                return logrus.InfoLevel, err</span>
        case WarnLevel:<span class="cov8" title="1">
                return logrus.WarnLevel, err</span>
        case DebugLevel:<span class="cov8" title="1">
                return logrus.DebugLevel, err</span>
        case ErrorLevel:<span class="cov8" title="1">
                return logrus.ErrorLevel, err</span>
        case PanicLevel:<span class="cov8" title="1">
                return logrus.PanicLevel, err</span>
        case FatalLevel:<span class="cov8" title="1">
                return logrus.FatalLevel, err</span>
        default:<span class="cov8" title="1">
                return logrus.Level(128), UnexpectedLevel</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"
        "os/signal"
        "syscall"
)

type ConfigDriver interface {
        LoadSyncConfig() (c SyncConfig, err error)
        UpdateSyncConfig(config SyncConfig) (err error)
}

// default drivers preset
var cfgDrivers = map[string]ConfigDriver{
        "default": DefaultConfigDriver{},
}

func main() <span class="cov0" title="0">{
        var cfg = new(ServerConfig)
        var logger *logrus.Logger
        var err error
        var server *Server
        var g errgroup.Group
        var syncCfg SyncConfig

        timeGen := SyncTimeGenerator{}
        if err = timeGen.SetLocalTime(); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "set_locale",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(
                logrus.Fields{
                        "stage": "init",
                        "state": "processing",
                },
        ).Infof("location set: %+v\n", timeGen.location)

        // load master config for application
        if err = cfg.Load(); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "load_config",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>

        <span class="cov0" title="0">if logger, err = SetupLogger(cfg.LogLevel, cfg.TimeFormat); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "setup_logger",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>

        // load sync config
        <span class="cov0" title="0">driver, ok := cfgDrivers[cfg.ConfigDriver]
        if !ok </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "setup_sync_driver",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatalf("unsupported config driver '%s'\n", cfg.ConfigDriver)
        }</span>

        <span class="cov0" title="0">if syncCfg, err = driver.LoadSyncConfig(); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "setup_sync_settings",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>

        // create sync operation lock (block)
        <span class="cov0" title="0">block := MakeBlock()
        if server, err = MakeServer(cfg, logger, block); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "setup_server",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>

        // make time generator for sync at wished time
        <span class="cov0" title="0">if err = timeGen.SetupSyncTime(syncCfg.SyncTime); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage":    "setup_sync_interval",
                                "state":    "failed",
                                "interval": syncCfg.SyncTime,
                                "error":    err.Error(),
                        },
                ).Fatal(err)
        }</span>

        <span class="cov0" title="0">sCtx, stop := signal.NotifyContext(
                context.Background(),
                syscall.SIGINT,
                syscall.SIGTERM,
        )
        defer stop()

        // run sync at start
        if err = SyncDirectories(sCtx, logger, syncCfg); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage":    "sync_at_start",
                                "state":    "failed",
                                "interval": syncCfg.SyncTime,
                                "error":    err.Error(),
                        },
                ).Error(err)
        }</span>

        <span class="cov0" title="0">syncScheduler, sErr := MakeScheduler(driver, &amp;timeGen)
        if sErr != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "run_server",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>
        <span class="cov0" title="0">server.SetConfigDriver(driver)

        g.Go(
                func() error </span><span class="cov0" title="0">{
                        e := server.Run(sCtx)
                        stop()
                        return e
                }</span>,
        )

        // run synchronization by timer
        <span class="cov0" title="0">g.Go(
                func() error </span><span class="cov0" title="0">{
                        e := syncScheduler.SyncByTimer(sCtx, logger, block)
                        stop()
                        return e
                }</span>,
        )

        <span class="cov0" title="0">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(
                        logrus.Fields{
                                "stage": "run_server",
                                "state": "failed",
                                "error": err.Error(),
                        },
                ).Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// server contains API commands available for user
package main

import (
        "context"
        "errors"
        "fmt"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/sirupsen/logrus"
        "net/http"
        "sync"
)

var BrokenServer = fmt.Errorf("broken server")

// Block is used to avoid long time in mutex
type Block struct {
        lock   *sync.RWMutex
        isFree bool
}

func MakeBlock() *Block <span class="cov8" title="1">{
        return &amp;Block{
                lock:   &amp;sync.RWMutex{},
                isFree: true,
        }
}</span>

// IsFree return Block availability for Lock
func (b *Block) IsFree() bool <span class="cov8" title="1">{
        b.lock.RLock()
        defer b.lock.RUnlock()
        return b.isFree
}</span>

// Lock try to lock. Return false if Block locked
func (b *Block) Lock() bool <span class="cov8" title="1">{
        b.lock.Lock()
        defer b.lock.Unlock()

        if !b.isFree </span><span class="cov8" title="1">{
                // lock is locked - return false
                return b.isFree
        }</span>

        <span class="cov8" title="1">b.isFree = false
        return true</span>
}

// Unlock try to unlock Block. Return true if Block unlocked
func (b *Block) Unlock() bool <span class="cov8" title="1">{
        b.lock.Lock()
        defer b.lock.Unlock()

        if b.isFree </span><span class="cov0" title="0">{
                return b.isFree
        }</span>

        <span class="cov8" title="1">b.isFree = true
        return b.isFree</span>
}

type LoaderUpdater interface {
        LoadSyncConfig() (s SyncConfig, err error)
        UpdateSyncConfig(config SyncConfig) (err error)
}

// Server used for handle API
type Server struct {
        g   *gin.Engine
        b   *Block
        log *logrus.Logger
        cfg *ServerConfig
        d   LoaderUpdater
}

// MakeServer factory function for create new server to handle API
func MakeServer(cfg *ServerConfig, log *logrus.Logger, b *Block) (
        s *Server,
        err error,
) <span class="cov0" title="0">{
        if cfg == nil || log == nil || b == nil </span><span class="cov0" title="0">{
                return s, fmt.Errorf(
                        "nil configuration attr: c=%p, l=%p, b=%p",
                        cfg,
                        log,
                        b,
                )
        }</span>

        <span class="cov0" title="0">return &amp;Server{
                b:   b,
                log: log,
                cfg: cfg,
        }, err</span>
}

func (srv *Server) SetConfigDriver(d LoaderUpdater) <span class="cov0" title="0">{
        srv.d = d
}</span>

// HandleSyncCommand handle unscheduled used command.
// Return http status 409 if operation running
func (srv *Server) HandleSyncCommand(c *gin.Context) <span class="cov0" title="0">{
        var syncReq SyncDirectoriesRequest
        var err error

        // Validate request
        if err = c.BindJSON(&amp;syncReq); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">vld := validator.New(validator.WithRequiredStructEnabled())
        if err = vld.Struct(&amp;syncReq); err != nil </span><span class="cov0" title="0">{
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        // we pass only first query to avoid accident with inconsistent files state
        <span class="cov0" title="0">if !srv.b.Lock() </span><span class="cov0" title="0">{
                // sema is closed - return 409 (conflict)
                c.AbortWithStatus(http.StatusConflict)
                return
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // unlock &amp; panic if Block is not unlocked
                if !srv.b.Unlock() </span><span class="cov0" title="0">{
                        panic("unsafe to continue - broken lock")</span>
                }
        }()

        // root directories have to be different
        <span class="cov0" title="0">if syncReq.SrcPath == syncReq.DstPath </span><span class="cov0" title="0">{
                _ = c.AbortWithError(
                        http.StatusBadRequest,
                        fmt.Errorf("equal sync path"),
                )
                return
        }</span>

        // we take a lock let`s handle command
        <span class="cov0" title="0">scfg := SyncConfig{
                SrcPath:        syncReq.SrcPath,
                DstPath:        syncReq.DstPath,
                MaxDiffPercent: syncReq.MaxDiffPercent,
        }

        ctx := context.Background()
        if err = SyncDirectories(ctx, srv.log, scfg); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
        }</span>
}

// UpdateConfiguration command for update server sync configuration
func (srv *Server) UpdateConfiguration(c *gin.Context) <span class="cov0" title="0">{
        var sCfg ChangeSyncConfig
        var err error

        // Validate request
        if err = c.BindJSON(&amp;sCfg); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusBadRequest, err)
                return
        }</span>

        <span class="cov0" title="0">vld := validator.New(validator.WithRequiredStructEnabled())
        if err = vld.Struct(&amp;sCfg); err != nil </span><span class="cov0" title="0">{
                c.AbortWithStatus(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">syncConfig := SyncConfig{
                SrcPath:        sCfg.SrcPath,
                DstPath:        sCfg.DstPath,
                SyncTime:       sCfg.SyncTime,
                MaxDiffPercent: sCfg.MaxDiffPercent,
        }

        if err = srv.d.UpdateSyncConfig(syncConfig); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">c.IndentedJSON(http.StatusOK, 200)</span>
}

// GetCurrentConfig return current synchronization config
func (srv *Server) GetCurrentConfig(c *gin.Context) <span class="cov0" title="0">{
        var cfg SyncConfig
        var err error

        if cfg, err = srv.d.LoadSyncConfig(); err != nil </span><span class="cov0" title="0">{
                _ = c.AbortWithError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">c.IndentedJSON(http.StatusOK, cfg)</span>
}

// Health for lifecycle handling
func (srv *Server) Health(c *gin.Context) <span class="cov0" title="0">{
        c.IndentedJSON(http.StatusOK, 200)
}</span>

// Run server
func (srv *Server) Run(ctx context.Context) (err error) <span class="cov0" title="0">{
        // setup gin router

        if srv.d == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config driver not set")
        }</span>

        <span class="cov0" title="0">if err = srv.setup(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">addr := fmt.Sprintf("%s:%s", srv.cfg.Host, srv.cfg.Port)
        server := &amp;http.Server{
                Addr:         addr,
                Handler:      srv.g,
                ReadTimeout:  srv.cfg.ConnReadTimeout,
                WriteTimeout: srv.cfg.ConnWriteTimeout,
        }

        go func() </span><span class="cov0" title="0">{
                if err = server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(
                        err,
                        http.ErrServerClosed,
                ) </span><span class="cov0" title="0">{
                        srv.log.Error(err)
                }</span>
        }()

        <span class="cov0" title="0">&lt;-ctx.Done()

        srv.log.Debugf("shutting down gracefully, press Ctrl + C to force")

        nc, cancel := context.WithTimeout(
                context.Background(),
                srv.cfg.GracefulShutdownTimeout,
        )
        defer cancel()

        if err = server.Shutdown(nc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">srv.log.Debugf("server exiting")
        return err</span>
}

func (srv *Server) setup() (err error) <span class="cov0" title="0">{
        // set loglevel for gin
        gin.SetMode(gin.DebugMode)

        srv.g = gin.Default()

        // setup CORS
        srv.g.Use(
                cors.New(
                        cors.Config{
                                AllowPrivateNetwork: true,
                                AllowHeaders:        srv.cfg.AllowedHeaders,
                                AllowMethods:        srv.cfg.AllowedMethods,
                                AllowOrigins:        srv.cfg.AllowedHosts,
                        },
                ),
        )

        // register sync handler
        srv.g.PATCH("/api/v1/sync/directories", srv.HandleSyncCommand)

        // register handler for update server config
        srv.g.PATCH("/api/v1/sync/config/update", srv.UpdateConfiguration)

        // register handler for return actual server config
        srv.g.GET("/api/v1/sync/config", srv.GetCurrentConfig)

        // register /health endpoint for control
        srv.g.GET("/api/v1/health", srv.Health)

        return err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Contains Synchronizer type for handle SyncCommand
package main

import (
        "context"
        "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"
        "io"
        "io/fs"
        "os"
        "runtime"
        "time"
)

type ItemHandler func(string) error

// Synchronizer for sync command parameters
type Synchronizer struct{}

func MakeSynchronizer() Synchronizer <span class="cov0" title="0">{
        return Synchronizer{}
}</span>

// Sync start sync operation
func (s Synchronizer) Sync(
        ctx context.Context,
        syncCmd SyncCommand,
        log *logrus.Logger,
) (err error) <span class="cov0" title="0">{
        gp := s.CalculatePoolSize()

        // delete directories
        log.WithFields(
                logrus.Fields{
                        "stage": "remove_dirs",
                        "state": "processing",
                },
        ).Debug("deleting directories")
        if err = s.DeleteDirectories(ctx, syncCmd, gp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // delete files
        <span class="cov0" title="0">log.WithFields(
                logrus.Fields{
                        "stage": "remove_files",
                        "state": "processing",
                },
        ).Debug("deleting files")
        if err = s.DeleteFiles(ctx, syncCmd, gp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create directories
        <span class="cov0" title="0">log.WithFields(
                logrus.Fields{
                        "stage": "create_new_dirs",
                        "state": "processing",
                },
        ).Debug("creating directories")
        if err = s.CreateDirectories(ctx, syncCmd, gp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // sync files
        <span class="cov0" title="0">log.WithFields(
                logrus.Fields{
                        "stage": "sync_files",
                        "state": "processing",
                },
        ).Debug("sync files")
        if err = s.SyncFiles(ctx, log, syncCmd, gp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.WithFields(
                logrus.Fields{
                        "stage": "synchronized",
                        "state": "success",
                },
        ).Debug("synchronization exited")
        return err</span>
}

// DeleteDirectories delete all wished directories from dest concurrently
func (s Synchronizer) DeleteDirectories(
        ctx context.Context,
        syncCmd SyncCommand,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        deleteDir := func(str string) error </span><span class="cov0" title="0">{ return s.deleteDir(str) }</span>
        <span class="cov0" title="0">return s.handleItems(
                ctx,
                syncCmd.DirsToDelete,
                concurrencyLim,
                deleteDir,
        )</span>
}

// DeleteFiles delete all wished files from dest concurrently
func (s Synchronizer) DeleteFiles(
        ctx context.Context,
        syncCmd SyncCommand,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        for _, files := range syncCmd.FilesToDelete </span><span class="cov0" title="0">{
                funcCall := func(str string) error </span><span class="cov0" title="0">{ return s.deleteFile(str) }</span>
                <span class="cov0" title="0">err = s.handleItems(
                        ctx, files, concurrencyLim, funcCall,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// CreateDirectories create all needed directories in dest concurrently
func (s Synchronizer) CreateDirectories(
        ctx context.Context,
        syncCmd SyncCommand,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        return s.handleNewDirectories(
                ctx,
                syncCmd.DirsToCreate,
                concurrencyLim,
        )
}</span>

// syncPair sync files pair
func (s Synchronizer) syncPair(
        ctx context.Context,
        log *logrus.Logger,
        pair SyncPair,
) (err error) <span class="cov0" title="0">{
        var srcFile, dstFile io.ReadWriteCloser

        // open src (take permissions from sync pair)
        srcFile, err = os.OpenFile(pair.Src, os.O_RDONLY, pair.Perm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer s.fclose(log, srcFile)

        // open dst (create file if not exists)
        dstFile, err = os.OpenFile(pair.Dst, os.O_CREATE|os.O_RDWR, pair.Perm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer s.fclose(log, dstFile)

        // handle ctx or signal (graceful shutdown)
        // later we can`t stop operation - it may break file...
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0">
                break</span>
        }

        // alloc buffer if files opened
        <span class="cov0" title="0">buf := make([]byte, DefaultBufferSize)
        _, err = io.CopyBuffer(dstFile, srcFile, buf)
        return err</span>
}

// SyncFiles sync all pairs between source and dest
func (s Synchronizer) SyncFiles(
        ctx context.Context,
        log *logrus.Logger,
        syncCmd SyncCommand,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        return s.handleFilePairs(ctx, log, syncCmd.SyncPairs, concurrencyLim)
}</span>

// deleteFile delete wished file. If file not exists return nil, if
// any error - error will be type *PathError
//
// Params:
//   - file: entire file path to delete
//
// Returns:
//   - err: if any error returns
func (s Synchronizer) deleteFile(file string) (err error) <span class="cov0" title="0">{
        if _, err = os.Stat(file); err == nil </span><span class="cov0" title="0">{
                return os.Remove(file)
        }</span>
        <span class="cov0" title="0">if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                // if file not exists - no error
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// deleteDir use RemoveAll under the hood
func (s Synchronizer) deleteDir(dir string) (err error) <span class="cov0" title="0">{
        return os.RemoveAll(dir)
}</span>

// createDirs use MkdirAll under the hood
// Create entire path
func (s Synchronizer) createDirs(
        root string,
        perm fs.FileMode,
) (err error) <span class="cov0" title="0">{
        return os.MkdirAll(root, perm)
}</span>

// CalculatePoolSize for disk io bound tasks
func (s Synchronizer) CalculatePoolSize() int <span class="cov0" title="0">{
        cc := runtime.NumCPU()
        if cc &lt; 2 </span><span class="cov0" title="0">{
                return cc
        }</span>

        <span class="cov0" title="0">return cc/2 + 1</span>
}

// HandlePaths handle two paths parallel
func HandlePaths(src string, dst string) (
        srcMeta SyncMeta,
        dstMeta SyncMeta,
        err error,
) <span class="cov0" title="0">{
        var g errgroup.Group

        srcMeta = MakeSyncMeta()
        dstMeta = MakeSyncMeta()

        g.Go(
                func() error </span><span class="cov0" title="0">{
                        return srcMeta.MakeMeta(src)
                }</span>,
        )

        <span class="cov0" title="0">g.Go(
                func() error </span><span class="cov0" title="0">{
                        return dstMeta.MakeMeta(dst)
                }</span>,
        )

        <span class="cov0" title="0">err = g.Wait()
        return srcMeta, dstMeta, err</span>
}

// handleItems is a concurrent runner that start goroutines pool inside
func (s Synchronizer) handleItems(
        ctx context.Context,
        items []string,
        concurrencyLim int,
        handler ItemHandler,
) (err error) <span class="cov0" title="0">{
        g := errgroup.Group{}

        tokens := make(chan struct{}, concurrencyLim)

        for i := 0; i &lt; concurrencyLim; i++ </span><span class="cov0" title="0">{
                tokens &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">for _, item := range items </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        goto out</span>
                case &lt;-tokens:<span class="cov0" title="0">
                        g.Go(
                                func() error </span><span class="cov0" title="0">{
                                        err = handler(item)
                                        tokens &lt;- struct{}{}
                                        return err
                                }</span>,
                        )
                }
        }

out:
        // wail for all running tasks
        <span class="cov0" title="0">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s Synchronizer) handleFilePairs(
        ctx context.Context,
        log *logrus.Logger,
        pairs []SyncPair,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        g := errgroup.Group{}

        tokens := make(chan struct{}, concurrencyLim)

        for i := 0; i &lt; concurrencyLim; i++ </span><span class="cov0" title="0">{
                tokens &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">for _, pair := range pairs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        goto out</span>
                case &lt;-tokens:<span class="cov0" title="0">
                        g.Go(
                                func() error </span><span class="cov0" title="0">{
                                        err = s.syncPair(ctx, log, pair)
                                        tokens &lt;- struct{}{}
                                        return err
                                }</span>,
                        )
                }
        }
out:
        <span class="cov0" title="0">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s Synchronizer) handleNewDirectories(
        ctx context.Context,
        newDirs []NewDirectory,
        concurrencyLim int,
) (err error) <span class="cov0" title="0">{
        var g errgroup.Group

        tokens := make(chan struct{}, concurrencyLim)

        for i := 0; i &lt; concurrencyLim; i++ </span><span class="cov0" title="0">{
                tokens &lt;- struct{}{}
        }</span>

        <span class="cov0" title="0">for _, nd := range newDirs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        goto out</span>
                case &lt;-tokens:<span class="cov0" title="0">
                        g.Go(
                                func() error </span><span class="cov0" title="0">{
                                        err = s.createDirs(nd.DirPath, nd.DirMode)
                                        tokens &lt;- struct{}{}
                                        return err
                                }</span>,
                        )
                }
        }
out:
        <span class="cov0" title="0">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}

// fclose internal function for deferred error handling from closed files.
// Can close readers and writers
func (s Synchronizer) fclose(log *logrus.Logger, file io.ReadWriteCloser) <span class="cov0" title="0">{
        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
        }</span>
}

type Driver interface {
        LoadSyncConfig() (c SyncConfig, err error)
}

// TimeGenerator generate intervals for repeat tasks
type TimeGenerator interface {
        GenerateInterval() (t time.Duration, err error)
        SetupSyncTime(tm string) (err error)
}

// SyncScheduler for run synchronization by time
type SyncScheduler struct {
        d  Driver
        tg TimeGenerator
}

// MakeScheduler factory
func MakeScheduler(d Driver, tg TimeGenerator) (s SyncScheduler, err error) <span class="cov0" title="0">{
        if tg == nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov0" title="0">return SyncScheduler{d: d, tg: tg}, err</span>
}

// ChangeSyncTime set new sync time to generate
func (s SyncScheduler) ChangeSyncTime(time string) (err error) <span class="cov0" title="0">{
        // tg is a pointer, so we can change them (state)
        return s.tg.SetupSyncTime(time)
}</span>

// SyncByTimer infinite loop activated by timer and run sync operation.
// If b (Block) is locked return error and wait next timer
func (s SyncScheduler) SyncByTimer(
        ctx context.Context,
        log *logrus.Logger,
        b *Block,
) (err error) <span class="cov0" title="0">{
        var tx time.Duration
        var syncCfg SyncConfig

        // create interval for timer
        if tx, err = s.tg.GenerateInterval(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">t := time.NewTimer(tx)

        // we may use go &lt; 1.23, so we have to care about timers
        defer t.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        if syncCfg, err = s.d.LoadSyncConfig(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // sync time may be changed, so we set new time each time we
                        // try to sync files
                        <span class="cov0" title="0">if err = s.ChangeSyncTime(syncCfg.SyncTime); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if b.Lock() </span><span class="cov0" title="0">{
                                // sync directories
                                err = SyncDirectories(ctx, log, syncCfg)
                                if !b.Unlock() </span><span class="cov0" title="0">{
                                        panic("broken Block")</span>
                                }

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        // not locked - any other sync running, let`s notify
                        // and wait next timer
                        // === time (set new interval for next sync)
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov0" title="0">
                                if tx, err = s.tg.GenerateInterval(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">log.WithFields(
                                        logrus.Fields{
                                                "stage":    "reset_timer",
                                                "state":    "finished",
                                                "interval": tx,
                                        },
                                ).Debug("reset sync interval")

                                t.Reset(tx)</span>
                        }
                }
                <span class="cov0" title="0">time.Sleep(1 * time.Second)</span>
        }
}

// SyncDirectories build and run sync operation, is a top-level
// function
func SyncDirectories(
        ctx context.Context,
        log *logrus.Logger,
        cfg SyncConfig,
) (err error) <span class="cov0" title="0">{
        var sm, dm SyncMeta

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0">
                break</span>
        }

        <span class="cov0" title="0">if sm, dm, err = HandlePaths(cfg.SrcPath, cfg.DstPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">syncCmd := MakeSyncCommand(cfg.MaxDiffPercent)
        if err = syncCmd.Prepare(sm, dm); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // start sync
        <span class="cov0" title="0">snc := MakeSynchronizer()
        return snc.Sync(ctx, syncCmd, log)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// package contains type for handle synchronization time

package main

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// DefaultTimePartsSeparator to parse h, m, s
const (
        DefaultTimePartsSeparator = ":"

        // numeric const section

        // RequiredTimePartsCount is 3 for hours, minutes and seconds
        RequiredTimePartsCount = 3

        MinPossibleTimeValue   = 0
        MaxPossibleHoursValue  = 23
        MaxPossibleMinSecValue = 59
)

// SyncTimeGenerator for handle sync time
type SyncTimeGenerator struct {
        H        int
        M        int
        S        int
        location *time.Location
}

// SetupSyncTime convert time string (like 12:45:15) into numeric values
// for hours, minutes and seconds
func (stp *SyncTimeGenerator) SetupSyncTime(tmFmt string) (err error) <span class="cov8" title="1">{

        parts := strings.Split(tmFmt, DefaultTimePartsSeparator)
        if len(parts) != RequiredTimePartsCount </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid time parts count")
        }</span>

        <span class="cov8" title="1">if err = stp.SetHours(parts[0]); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err = stp.SetMinutes(parts[1]); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err = stp.SetSeconds(parts[2]); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return err</span>
}

// SetHours (int) from time string
func (stp *SyncTimeGenerator) SetHours(h string) (err error) <span class="cov8" title="1">{
        if stp.H, err = strconv.Atoi(h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if stp.H &lt; MinPossibleTimeValue || stp.H &gt; MaxPossibleHoursValue </span><span class="cov8" title="1">{
                return fmt.Errorf("hours have to be in between of 0 and 23")
        }</span>

        <span class="cov8" title="1">return err</span>
}

// SetMinutes (int) from time string
func (stp *SyncTimeGenerator) SetMinutes(m string) (err error) <span class="cov8" title="1">{
        if stp.M, err = strconv.Atoi(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if stp.M &lt; MinPossibleTimeValue || stp.M &gt; MaxPossibleMinSecValue </span><span class="cov8" title="1">{
                return fmt.Errorf("minutes have to be in between of 0 and 59")
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (stp *SyncTimeGenerator) SetSeconds(s string) (err error) <span class="cov8" title="1">{
        if stp.S, err = strconv.Atoi(s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if stp.S &lt; MinPossibleTimeValue || stp.S &gt; MaxPossibleMinSecValue </span><span class="cov8" title="1">{
                return fmt.Errorf("seconds have to be in between of 0 and 59")
        }</span>
        <span class="cov8" title="1">return err</span>
}

// SetSyncTime from current time
func (stp *SyncTimeGenerator) SetSyncTime(origin time.Time) (
        t time.Duration,
        err error,
) <span class="cov0" title="0">{
        // set basic time
        y, m, day := origin.Date()
        tSync := time.Date(y, m, day, stp.H, stp.M, stp.S, 0, stp.location)

        if origin.After(tSync) </span><span class="cov0" title="0">{
                // add 24 hours for truncated because it before current time
                tSync = tSync.Add(24 * time.Hour)
        }</span>

        <span class="cov0" title="0">return tSync.Sub(origin), err</span>
}

// GetLocalTime get time for current location (timezone)
func (stp *SyncTimeGenerator) GetLocalTime() (t time.Time, err error) <span class="cov0" title="0">{
        if stp.location == nil </span><span class="cov0" title="0">{
                // we have to set local time
                if err = stp.SetLocalTime(); err != nil </span><span class="cov0" title="0">{
                        return t, err
                }</span>
        }

        <span class="cov0" title="0">return time.Now().Local(), err</span>
}

// GenerateInterval for repeat wished operation (or set timer object)
func (stp *SyncTimeGenerator) GenerateInterval() (d time.Duration, err error) <span class="cov0" title="0">{
        var tm time.Time

        if tm, err = stp.GetLocalTime(); err != nil </span><span class="cov0" title="0">{
                return d, err
        }</span>

        <span class="cov0" title="0">return stp.SetSyncTime(tm)</span>
}

// SetLocalTime from OS settings (/etc/localtime)
func (stp *SyncTimeGenerator) SetLocalTime() (err error) <span class="cov0" title="0">{
        var link, location string

        if link, err = os.Readlink("/etc/localtime"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">parts := strings.Split(link, "/")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("broken localtime description '%s'\n", link)
        }</span>

        <span class="cov0" title="0">location = strings.Join(parts[len(parts)-2:], "/")
        if stp.location, err = time.LoadLocation(location); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
